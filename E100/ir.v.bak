/*
 * Copyright (c) 2019, Devin Ardeshna, John Hill, Tara Sabbineni, Kevin Yan. 
 * All rights reserved. Borrowing style & insight from P. Chen's extensive previous work.
 * This software is supplied as is without expressed or implied
 * warranties of any kind.
 */

/*
 * Controller to help read and write data to IR reflectance sensor using the DE2-115's GPIO pins.
 * Sets a register ir_count, sets the output high, and counts how long the return value given by the sensor
 * (ir_capacitor_high) is high up until 3 ms in ir_count.
 */
 
module ir(
	input wire clock,
	input wire clock_valid,
	input wire reset,

	//E100 Interface
	output reg [17:0] ir_count, // Register to store count value, between 0 and 3000
	inout ir_readWrite); // Read in from sensor at GPIO9

	reg [2:0] state, next_state;
	reg next_ir_readWrite; //Use to determine if reading or writing
	reg [17:0] counter, next_counter, next_ir_count;
	
	
	

	parameter state_charge   = 2'h0; // charge capacitor until 10 micro sec
	parameter state_read     = 2'h1; // read value from line sensor for  3 mili sec OR outputs 0
	parameter state_report_num   = 2'h2; // report value of capicitor (count)
	
	//counter u1(clock, crest, ready, ir_readWrite, ir_count);
	
	// IR Control, set at clock of 100 MHz, period of 20 ns
	// Wait until command flag the capacitor is charged using ir_out, then raise response flag
	// At every rising edge of the clock (every 20 ns), read in from the sensor's capacitor and increment count
	// When capacitor discharges, or at 3000 ns, copy value of count to register, and lower response flag, then wait again for command flag
	
	always @(posedge clock) begin
		if (clock_valid == 1'b0) begin
		if(reset == 1'b1) begin
			state <= state_reset; end
		else begin
			state <= next_state;
			ir_count <= next_ir_count;
			counter <= next_counter;
			ir_readWrite = next_ir_readWrite;
		end
		end
	end
	
	// Finite state machine to implement IO command/response protocol
	// & Logic for ir_count
	always @* begin
		next_state = state_charge;
		
		case (state)

			state_charge: begin
				if(counter < 18'd500) begin
					next_ir_readWrite = 1'b1;
					next_counter = counter + 18'd1;
					next_state = state_charge;
				end
				else begin next_counter = 18'd0;
				next_state = state_read; 
				end
				
			end
			
			state_read: begin
				if((counter >= 18'd150000) | ) begin
					next_ir_count = counter;
					next_state = state_report_num;
					next_counter = 18'd0; end 
				else begin
					next_counter = counter + 18'd1;
					next_state = state_read; end
			end
			
			state_report_num: begin
				if(counter >= 18'd2) begin
					next_state = state_charge; end
				else begin
					next_state = state_report_num;
					next_counter = counter + 18'd1;
				end
			end
		endcase
	end
endmodule
